<img src="/Tracking_Time/4_Apr/250428.png">

### 깃이 뭔데
- 로컬에서 관리하고 변경사항을 중앙으로 업로드하는 버전관리시스템
- 로컬에서 관리하기 때문에 빠르지만 중앙에서 관리하는 것보다 복잡하고 동기화 중 충돌 가능성
- SVN은 중앙 집중식 버전관리시스템, 하나의 서버에서만 변경사항을 관리하므로 동기화가 쉽지만 사용자 수에 따른 커밋 빈도에 대한 부하, 브랜치 및 머지 기능이 복잡함

### 자바는 컴파일 언어냐 인터프리터 언어냐
- 자바는 둘 다 쓴다. 그래서 하이브리드 언어라고도 한다.
- java파일을 javac파일로 컴파일 이후 인터프리터 방식으로 실행됨
  - 그러다가 자주 실행되는 구간이 있으면 JIT 컴파일러에 의해 바이트코드를 기계어로 컴파일하여 캐시에 저장함
```
.java (소스코드)
   ↓ javac
.class (바이트코드)
   ↓ ClassLoader
[메모리 로딩]
   ↓
[인터프리터] (처음엔 한 줄씩 읽어서 실행)
   ↓ (자주 실행되는 코드 발견)
[JIT 컴파일러] (기계어로 변환하여 최적화)
   ↓
[네이티브 코드 실행] (빠른 속도로 실행)
```
### 객체지향 5원칙
- SRP : 한놈은 한 책임만
- OCP : 확장은 ok, 수정은 ㄴㄴ / 새로운 기능 추가 시 기존 코드 수정하면 안됨 => **스프링 JDBC**
- LSP : 자식 클래스는 부모 클래스 대체 가능 / car를 tesla로 바꿔도 동작해야 함 => **다형성**
- ISP : 인터페이스도 쪼개서 사용 안하는 인터페이스에 의존 안하게 만들어버리기
- DIP : 추상적인 상위 객체를 의존해야지 구현체에 의존하면 안된다잉 => 이것도 많이 물어봄(스프링 **DI**)
  - 자 여기서 복습하는 의존성주입(Dependency Injection) : 빈 설정을 통해 어떤 구현체를 주입할지 스프링이 알아서 주입해줌. 그러니까 나는 상위 추상체(인터페이스)만 알면 되는거임

### 디자인패턴?
- 소프트웨어 특정 문제를 해결하기 위한 솔루션 템플릿

### 쿠키, 세션스토리지, 로컬스토리지
- 쿠키 : 자동으로 서버에 전송됨, XSS, CSRF, 중간자공격에 취약
- 세션스토리지 : 탭마다 보관되는 데이터, 서버에 전송안됨, XSS 주의
- 로컬스토리지 : 브라우저 전체 보관, 서버에 전송안됨, XSS 주의

### DNS란?
- 도메인 이름을 ip주소로 변경해주는 시스템
- DNS 동작원리
  1. 먼저 DNS 캐시를 뒤짐
  2. 뒤져서 안나오면 그때 IP주소를 요청하는 재귀적 쿼리를 로컬 DNS서버에 보냄
  3. 로컬 DNS 서버는 루트 서버에 요청함(반복적 쿼리). 그러면 TLD 서버를 알려줌
  4. TLD서버에 요청함(반복적 쿼리). 그러면 권한 있는 네임서버를 알려줌
  5. 권한 있는 네임서버에 요청함(반복적 쿼리). 그러면 IP주소를 알려줌
  6. 로컬 DNS서버는 이걸 캐시에 저장하고 사용자에게 재귀적 응답으로 반환함

### HTTP, HTTPS 차이
- HTTP에 SSL/TLS 보안계층이 추가된 프로토콜

### HTTP 1.1과 2.0 차이
- HTTP 1.1
  - 요청마다 새로운 연결, 파이프라인, keep-alive로 해결했지만 효율적이지 못함
  - 클라이언트가 요청한 리소스만 보냄(html -> html, 사진이나 기타 등등은 안보냄, 네트워킹 비용 증가)
  - 텍스트기반 헤더로 용량 큼
- HTTO 2.0
  - Multiplexing을 통한 여러개의 요청과 응답 처리 가능
  - 바이너리 기반으로 헤더 전송, 헤더 압축
  - 추가적인 요청 없어도 관련된 리소스 보낼 수 있음
- HTTP 3.0
  - UDP(QUIC)기반이어서 빠름
  - 0-RTT(제로 RTT) 핸드쉐이크 가능 -> 만약 이전에 통신했던 서버라면(세션키를 알고있다면) 핸드쉐이크 없이 바로 통신 가능
  - 스트림 단위로 관리되므로 패킷이 일부 손실되도 영향없이 데이터 전송 가능
  - ```
    패킷1 → 패킷2 → [패킷3 손실] → 패킷4 대기 → 패킷5 대기

    
    스트림A: 패킷1 → 패킷2 → [패킷3 손실] (재전송 기다림)
    스트림B: 패킷1 → 패킷2 → 패킷3 → 패킷4 (정상 처리)
    스트림C: 패킷1 → 패킷2 (정상 처리)
    ```
    

### TCP UDP 차이
- 신뢰성
  - TCP는 연결지향방식, 핸드쉐이크 과정 있음
  - UDP는 비연결 방식으로, 연결 설정이나 해제과정 없음
- 흐름 제어
  - TCP는 송수신 버퍼로 하나의 큐 사용, 슬라이딩 윈도우로 관리하여 오버플로우 발생하지 않게 관리 가능
  - UDP는 송수신 큐를 별도로 두어 각각의 큐에 오버플로우가 발생하지 않도록 운영체제에서 흐름 관리 -> 별도의 흐름제어 없음
- 혼잡 제어
  - TCP는 패킷 수를 관리함, 받을 수 있는 양으로만 패킷 보내야 하기 때문에, 대포적인 예시가 슬로우 스타트 -> 넘치면 다시 패킷의 수를 가장 적게 하여 다시 보냄
  - UDP는 별도의 혼잡제어 알고리즘이 없음