## Lock이란?
- 한 스레드만 공유자원에 접근하게 하여 데이터 무결성을 보호하는 기술.
- 이를 통해 공유 자원의 데이터 무결성을 보장하고, 작업이 중단없이 수행되거나 아무것도 수행되지 않도록 함(원자성)
  - 원자성이란? : 작업 단위가 더 이상 나뉠 수 없는 하나의 실행단위로 동작함.
    - 그렇기에 원자성이 보장된 연산이란 실행되거나 실행되지 않거나 둘 중 하나이다.
- 락의 종류 : 스핀락, 낙관적 락, 뮤텍스, read-write락

### 스핀락
- 어떤 스레드가 공유자원을 점유하여 락이 걸린 상태일 때 다른 스레드가 락이 해제되길 기다리며 계속 락 해제여부를 확인하는 방식
  - 여기서 중요한 점은 계속 락 해제 여부를 확인한다는 점이다. 이것을 busy-waiting이라고 한다.
  - 이 과정에서 대기하고 있는 스레드는 스케쥴링 큐로 내려가는 것이 아니라 계속 Runnable상태를 유지한다. 즉, 계속 CPU의 자원을 소모한다.
  - 장점
    - 락이 해제되면 컨텍스트 스위칭 과정 없이 바로 점유가 가능하다. 즉 빠른 공유자원 선점이 가능하다.
    - 컨텍스트 스위칭 과정이 없어 그에 따른 오버헤드가 없다.
    - 구현이 간단하다.
  - 단점
    - busy-waiting이므로 계속 CPU 자원을 소모한다.
    - 락 해제가 오래걸릴 경우(이전 스레드가 자원을 오래 점유하고 있을 경우) 비효율적으로 오래 CPU에 남아있는다.
    - 단일 CPU환경에서는 락을 점유한 스레드와 대기중인 스레드가 동시에 실행될 수 없기에 비효율적이다.
- 스핀락이 효율적일 때는 스레드의 락 해제가 빠를 경우이다.
- 이렇게 생각해도 좋다. 컨텍스트 스위칭이 매우 잦아 오버헤드가 많이 발생해 이를 줄이고 싶다면 스핀락을 고려하는 방향으로 생각해도 괜찮다.

### 낙관적 락
- 말 그대로 낙관적으로 생각하는 거다.
  - 데이터의 충돌은 매우 적을 것이라고 생각하는 것이다. 그렇기에 자원에 접근할 때 락을 걸지 않는다.
  - 작업 완료 후 충돌 여부를 확인하고, 충돌하면 롤백한다.
  - 장점
    - 만약 정말로 충돌이 적은 자원이라면 성능이 매우 뛰어나다.
    - 락을 안걸기 때문에 락 설정, 해제에 따른 오버헤드가 적다.
    - 락을 걸지 않기 때문에 병렬처리에도 효과적이다.
  - 단점
    - 만약 충돌이 잦다면 버전을 확인하고 롤백하는 과정에서 자원을 많이 소모한다.
    - 충돌을 감지해야 하고, 복구 로직을 구현해야 하므로 복잡하다.

### 뮤텍스 락
- 뮤텍스(Mutex)는 Mutual(상호) Exclusion(배제), 즉 상호배제라는 뜻이다.
- 스레드가 자원을 점유하고 있으면 락이 걸리고 다른 스레드는 해당 자원에 락이 걸려있으면 접근하지 못하고 뮤텍스 대기큐에 들어가게 된다.
- 해당 자원에 대한 점유가 끝나면 락이 해제되고(소유권을 반납하고) 뮤텍스 대기큐의 첫번째 스레드에 접근해도 좋다는 신호가 가고, 그때 다시 접근 시도하게 된다.
  - 장점
    - 사용하면 락 걸리고, 락 걸리면 못들어가고, 직관적임
    - 데이터 무결성 보장
    - 대부분 동기화 문제에 쉽게 적용 가능
  - 단점
    - 스핀락과 달리 대기하고 있는 스레드가 Runnable상태에서 wait상태로 전환된다. 이러면 컨텍스트 스위칭이 발생하고, 그에따른 오버헤드가 발생할 수 있다.
    - 스레드가 락을 해제하지 못하면 데드락 발생 가능성이 있다.
      - 참고 : 데드락 발생조건 : mutual exclusion, hold and wait, circular wait, no preemption
    - 한번에 하나의 스레드만 사용하여 병렬 처리가 제한됨


### 조건변수를 곁들인 뮤텍스
- 조건변수란 스레드가 특정 조건을 만족하거나 다른 스레드가 신호를 보낼때 대기중인 스레드를 깨우는 매커니즘이다.
- 다른 락 종류와는 사용하지 않는다. '불필요하게 CPU를 점유하는 스레드가 없을때' 효과적이다.
  - 뮤텍스만을 사용하면 프로세스가 뮤텍스를 지속 감시해야 하는 단점이 있는데, 조건변수를 도입하면 조건변수가 알아서 스레드를 깨우기 때문에 효과적이다.
  - 스레드가 공유자원에 락을 걸면 다른 스레드는 접근 시도하다가 실패하고 조건변수 대기큐로 간다.
  - 특정 조건을 만족하거나 다른 스레드가 신호를 보내면 조건변수 대기큐의 첫번째 스레드가 신호를 받아 자원 점유를 시도한다.
  - 만약 그사이 다른 스레드가 점유하고 있으면 스레드 대기큐로 간다.

### Read-Write 락
- Read와 Write 작업을 분리하여 락을 관리함
- 여러 Reader는 공유자원에 동시에 접근할 수 있지만, Writer는 하나만 접근이 가능하다.
  - 경우 1) Reader가 자원 점유 시 다른 Reader 스레드가 접근 -> 접근 허용
  - 경우 2) Reader가 자원 점유 시 Writer 스레드가 접근 -> 락 걸음. reader가 writer 큐에서 해당 스레드가 끝날때까지 대기해야 함
  - 경우 3) Writer가 자원 점유 시 Writer / Reader 스레드 접근 -> 락 걸음, 각각 writer/reader 큐에서 기다려야 함
- 장점
  - 다수의 Reader가 동시에 접근할 수 있어 읽기 중심 성능 향상
  - Writer에 대해 락을 걸어 쓰기에 대한 데이터 무결성 보장
  - 읽기 작업이 많고 쓰기 작업이 적은 경우 효율적으로 리소스 관리 가능
- 단점
  - Reader가 많을 경우 Writer가 자원을 점유하지 못해 Writer 기아현상 발생
  - Reader, Writer 스레드를 구분해야 하므로 단순 뮤텍스보다 복잡
  - Reader와 Writer 간의 잘못된 락 요청 순서로 인해 데드락 발생 가능성


### 세마포어(vs 뮤텍스)
- 공유자원에 대한 다중접근을 제한하는 방법
- 락을 거는 방식이 아님 -> 뮤텍스와 가장 큰 차이!
- S, P 연산, V 연산 개념이 있음
  - S : 세마포어 값, 점유 가능한 자원의 수
  - P 연산 : 세마포어의 값을 감소시킴 / 공유 가능한 자원 권한의 수를 줄임
  - V 연산 : 세마포어의 값을 증가시킴 / 공유 가능한 자원 권한의 수를 늘림
- 이진 세마포어 : 자원의 개수가 하나일 때의 세마포어 방식
  - 자원 하나에 대한 공유 여부를 결정하는 점에서는 뮤텍스와 유사하지만 차이가 있음
    - 뮤텍스 : 스레드가 공유 자원에 대한 소유권을 가짐
    - 세마포어 : 스레드가 공유 자원에 대한 소유권을 가지지 않음